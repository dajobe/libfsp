#CC=clang
#SAN_FLAGS=-fsanitize=address -O1 -fno-omit-frame-pointer

# Strict warning flags - generated code must compile warning-free
# For maximum warnings in development, uncomment the full set:
#WARN_FLAGS=-Wno-nullability-completeness -std=c11 -Wall -Wc++-compat -Wextra -Wpedantic -Wunused -Waggregate-return -Wbad-function-cast -Wcast-align -Wdisabled-optimization -Wendif-labels -Werror-implicit-function-declaration -Wfloat-equal -Wformat=2 -Wframe-larger-than=4096 -Winit-self -Winline -Wmissing-declarations -Wmissing-format-attribute -Wmissing-noreturn -Wmissing-prototypes -Wnested-externs -Wold-style-definition -Wpacked -Wpointer-arith -Wredundant-decls -Wshadow -Wsign-compare -Wstrict-overflow -Wstrict-prototypes -Wswitch-enum -Wunreachable-code -Wwrite-strings -Wno-missing-field-initializers -Wno-system-headers -Wno-unused-parameter -Wswitch-bool -Wlogical-not-parentheses -Wsizeof-array-argument -Wshorten-64-to-32
# Or use a more moderate set (configure.ac auto-detects supported flags):
WARN_FLAGS=-Wall -Wextra -Wpedantic
# Uncomment to treat warnings as errors (recommended for development)
#WARN_FLAGS+=-Werror

DEBUG_FLAGS=-g3 $(WARN_FLAGS)

FSPLIB=libfsp.a
FSPLIBSRCS=fsp.c
FSPLIBHDRS=fsp.h fsp_internal.h

LIBS=$(FSPLIB)

TESTSRCS=fsp_test.c test_lexer.c test_parser.c
TESTS=fsp_test

# Generated files from flex/bison
GENERATED=test_lexer.c test_lexer.h test_parser.c test_parser.h test_parser.output

CLEANFILES=$(TESTS) $(LIBS) \
stamp-h1 \
test_lexer.t \
$(GENERATED)

FILES=README.md \
GNUMakefile \
AUTHORS ChangeLog COPYING COPYING.LIB LICENSE.txt LICENSE-2.0.txt \
NOTICE NEWS configure.ac Makefile.am \
test_lexer.l test_parser.y \
$(FSPLIBSRCS) $(FSPLIBHDRS) fsp_test.c \
tests/simple.txt tests/simple.expected \
tests/triple-quoted.txt tests/triple-quoted.expected \
tests/mixed.txt tests/mixed.expected \
tests/empty.txt tests/empty.expected \
tests/long_string.txt tests/long_string.expected \
tests/missing_semicolon.txt tests/unterminated_string.txt \
fuzz_fsp_parse.c dicts/fsp.dict FUZZING.md

PACKAGE=libfsp
VERSION=0.1.0

PV=$(PACKAGE)-$(VERSION)
TARBALL=$(PV).tar.gz

LEX=flex
# Use Homebrew bison on macOS if available, otherwise system bison
BISON?=$(shell which /opt/homebrew/opt/bison/bin/bison 2>/dev/null || which bison)
PYTHON3=python3

LDFLAGS=$(DEBUG_FLAGS) $(SAN_FLAGS)
CPPFLAGS=$(DEBUG_FLAGS) -I. -DHAVE_FSP_CONFIG_H -DHAVE_STDLIB_H -DHAVE_STRING_H
CFLAGS=$(SAN_FLAGS)

FSPLIBOBJS=$(FSPLIBSRCS:.c=.o)
TESTOBJS=$(TESTSRCS:.c=.o)

all: $(LIBS) $(TESTS)

# Create fsp_config.h from fsp_config_standalone.h for standalone builds
fsp_config.h: fsp_config_standalone.h
	@if test ! -r fsp_config.h; then \
	  echo ln -s fsp_config_standalone.h fsp_config.h; \
	  ln -s fsp_config_standalone.h fsp_config.h; \
	fi

# Library deps
fsp.c: fsp.h fsp_config.h
fsp.h: fsp_config.h
$(FSPLIBSRCS): fsp_internal.h

$(FSPLIB): $(FSPLIBOBJS)
	$(AR) rv $@ $?

# Test lexer and parser generation with postprocess scripts
test_lexer.c: test_lexer.l test_parser.c scripts/postprocess-flex.py
	$(LEX) -o$@ $<
	for file in test_lexer.c test_lexer.h; do \
	  if [ -f $$file ]; then \
	    $(PYTHON3) scripts/postprocess-flex.py $$file > $$file.tmp || exit 1; \
	    mv -f $$file.tmp $$file; \
	  fi; \
	done

test_parser.c: test_parser.y scripts/postprocess-bison.py
	$(BISON) -o $@ $<
	$(PYTHON3) scripts/postprocess-bison.py $@

test_parser.h: test_parser.c
	@true

test_lexer.h: test_lexer.c
	@true

# Test program
fsp_test: $(TESTOBJS) $(FSPLIB)
	$(CC) $(LDFLAGS) -o $@ $(TESTOBJS) $(FSPLIB)

# Object dependencies
fsp_test.o: fsp_test.c fsp.h test_parser.h test_lexer.h
test_lexer.o: test_lexer.c test_parser.h fsp.h
test_parser.o: test_parser.c fsp.h

dist: $(FILES)
	rm -rf $(PV) && \
	mkdir -p $(PV)/tests && \
	mkdir -p $(PV)/scripts && \
	mkdir -p $(PV)/corpus/parse && \
	mkdir -p $(PV)/dicts && \
	cp $(FILES) $(PV) && \
	cp tests/*.txt $(PV)/tests/ 2>/dev/null || true && \
	cp tests/*.expected $(PV)/tests/ 2>/dev/null || true && \
	cp scripts/*.py scripts/README.md $(PV)/scripts/ && \
	cp corpus/parse/* $(PV)/corpus/parse/ && \
	cp dicts/* $(PV)/dicts/ && \
	tar cfz $(TARBALL) $(PV) && \
	rm -rf $(PV)

clean:
	rm -f *.o *~ *.tar.gz $(CLEANFILES)

check: $(TESTS)
	@rc=0; \
	for t in $(TESTS); do \
	  echo "Running test $$t"; \
	  ./$$t; \
	  status=$$?; \
	  if test $$status != 0; then \
	    rc=1; \
	  fi; \
	done; \
	exit $$rc

# ------------------------------
# Fuzzing (Clang + libFuzzer)
# ------------------------------
CLANG ?= clang
LIB_SAN_FLAGS = -fsanitize=address,undefined -fno-omit-frame-pointer -O1 -g
FUZZ_CFLAGS = -fsanitize=fuzzer,address,undefined -fno-omit-frame-pointer -O1 -g
# libFuzzer runtime automatically adds -lstdc++, ensure it can be found on ARM64
FUZZ_LDFLAGS = -fsanitize=fuzzer,address,undefined -L/usr/lib/aarch64-linux-gnu -L/usr/lib/x86_64-linux-gnu

.PHONY: fuzz-lib fuzz fuzz-clean

# Rebuild the library with clang and sanitizers suitable for fuzzing
# Use .NOTPARALLEL to ensure sequential execution and avoid race conditions
.NOTPARALLEL: fuzz-lib
fuzz-lib:
	@# Clean all object files and generated sources
	rm -f fsp.o libfsp.a test_lexer.o test_lexer.c test_lexer.h test_parser.o test_parser.c test_parser.h
	@# First, generate lexer/parser sources (without compiling) - must complete before next step
	+$(MAKE) -f GNUMakefile test_lexer.c test_parser.c
	@# Then compile everything with sanitizers
	+$(MAKE) -f GNUMakefile CC=$(CLANG) SAN_FLAGS="$(LIB_SAN_FLAGS)" libfsp.a test_lexer.o test_parser.o

fuzz_fsp_parse.o: fuzz_fsp_parse.c fsp.h test_parser.h test_lexer.h
	$(CLANG) $(FUZZ_CFLAGS) -I. -DHAVE_FSP_CONFIG_H -DHAVE_STDLIB_H -DHAVE_STRING_H -c -o $@ $<

fuzz_fsp_parse: fuzz-lib fuzz_fsp_parse.o $(FSPLIB) test_lexer.o test_parser.o
	$(CLANG) $(FUZZ_CFLAGS) -o $@ fuzz_fsp_parse.o test_lexer.o test_parser.o $(FSPLIB) $(FUZZ_LDFLAGS)

fuzz: fuzz_fsp_parse

fuzz-clean:
	rm -f fuzz_fsp_parse fuzz_fsp_parse.o

# Convenience run targets
FUZZ_TIMEOUT ?= 10
FUZZ_TIME ?= 60
FUZZ_DICT ?= dicts/fsp.dict
PARSE_CORPUS ?= corpus/parse

.PHONY: fuzz-parse-run artifacts

artifacts:
	mkdir -p artifacts

fuzz-parse-run: fuzz_fsp_parse artifacts
	./fuzz_fsp_parse -detect_leaks=0 -timeout=$(FUZZ_TIMEOUT) -max_total_time=$(FUZZ_TIME) -artifact_prefix=artifacts/ -dict=$(FUZZ_DICT) $(PARSE_CORPUS)
