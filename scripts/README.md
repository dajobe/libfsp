# libfsp Build Helper Scripts

This directory contains Python scripts for post-processing C code generated by
Flex and Bison.

## Primary Purpose: Zero-Warning Compilation

**These scripts exist to ensure generated code compiles with ZERO warnings at
high warning levels** (including `-Wall -Wextra -Wpedantic -Werror`).

Flex and Bison generate code that, while functionally correct, often produces
numerous compiler warnings. These scripts systematically eliminate those warnings
while preserving the semantic behavior of the generated code.

A project using these scripts should achieve warning-free compilation of all
generated lexer and parser code.

## Scripts

### calculate-min-buffer.py

Analyzes a Flex lexer file (`.l`) and calculates the optimal `MIN_BUFFER_FOR_LEX` value needed for proper streaming integration.

**What it does:**

- Extracts all token patterns from the lexer rules section
- Identifies fixed-length tokens (keywords, operators, delimiters)
- Distinguishes variable-length tokens (strings, URIs, comments)
- Calculates the longest fixed-length token
- Recommends a `MIN_BUFFER_FOR_LEX` value with headroom

**Key insight:** MIN_BUFFER_FOR_LEX only needs to be large enough for Flex to **recognize token delimiters**, not to hold entire token content. Variable-length tokens like strings and URIs accumulate incrementally once recognized.

**Usage:**

```bash
# Analyze a lexer file
python3 calculate-min-buffer.py your_lexer.l

# Quiet mode (numeric output only)
python3 calculate-min-buffer.py -q your_lexer.l

# Verbose mode (show all patterns)
python3 calculate-min-buffer.py -v your_lexer.l
```

**Example output:**

```
Analyzing sparql_lexer.l...
======================================================================
Fixed-length patterns found: 146
Variable-length patterns: 28

Longest fixed-length token:
  Pattern: [Cc][Uu][Rr][Rr][Ee][Nn][Tt]_[Dd][Aa][Tt][Ee][Tt][Ii][Mm][Ee]
  Length:  16 bytes
  Description: pattern requires ~16 chars

Recommended MIN_BUFFER_FOR_LEX:
  Minimum safe: 16 bytes (exact)
  Recommended:  32 bytes (with headroom)

#define MIN_BUFFER_FOR_LEX 32
```

**Tested on:**
- libfsp test_lexer.l: 32 bytes (longest: "print" = 5 bytes)
- Raptor turtle_lexer.l: 32 bytes (longest: pattern = 14 bytes)
- Rasqal sparql_lexer.l: 32 bytes (longest: "CURRENT_DATETIME" = 16 bytes)

### postprocess-flex.py

Post-processes C code generated by Flex lexers to achieve zero-warning compilation.

**Warnings and issues fixed:**

- **Unused function warnings**: Removes unnecessary `yy_fatal_error` declarations and definitions
- **Implicit function declarations**: Replaces `yy_fatal_error` calls with `YY_FATAL_ERROR` macro
- **Platform compatibility**: Wraps `#include <unistd.h>` with `YY_NO_UNISTD_H` guard
- **Sign comparison warnings**: Fixes signed/unsigned comparison in buffer operations
- **Type mismatch warnings**: Fixes declaration types (int â†’ yy_size_t where appropriate)
- **Memory leak warnings**: Adds cleanup calls in lexer destroy functions
- **Function signature mismatches**: Fixes `_scan_bytes` function signature
- **Macro expansion issues**: Fixes YY_CURRENT_BUFFER macro usage in buffer management
- **Integer type warnings**: Makes buffer size and character count variables properly typed
- **Line number tracking**: Updates #line directives with correct line numbers after modifications

**Usage:**

```bash
flex -o output.c input.l
python3 postprocess-flex.py output.c > output.tmp
mv output.tmp output.c
```

**Important Options:**

```bash
# Specify your project's config header (highly recommended for host projects)
python3 postprocess-flex.py -c myproject_config.h output.c > output.tmp

# Examples for specific projects:
python3 postprocess-flex.py -c raptor_config.h turtle_lexer.c > turtle_lexer.tmp
python3 postprocess-flex.py -c rasqal_config.h sparql_lexer.c > sparql_lexer.tmp
```

**Note:** Host projects should use the `-c/--config-header` option to specify their
own config header name (e.g., `raptor_config.h`, `rasqal_config.h`) instead of the
default `config.h`.

### postprocess-bison.py

Post-processes C code generated by Bison parsers to achieve zero-warning compilation.

**Warnings and issues fixed:**

- **Unused variable warnings**: Removes code blocks that cause warnings (e.g., `yyerrlab1`)
- **Macro redefinition warnings**: Fixes macro name collisions with temporary variables
- **Conflicting type warnings**: Removes duplicate prototypes for malloc/free
- **Missing case warnings**: Adds default case to syntax error handler (Bison <3.0.5)
- **Static analyzer issues**: Sets yytoken to non-negative value (prevents Coverity warnings)
- **Dead code warnings**: Removes always-false conditional checks
- **Switch enum warnings**: Adds `#pragma GCC diagnostic` around switch statements in yydestruct
- **Unused variable warnings**: Comments out unused yynerrs variable references
- **Empty declaration warnings**: Removes or comments problematic empty declarations
- **Line number tracking**: Updates #line directives with correct line numbers after modifications

**Usage:**

```bash
bison -o output.c input.y
python3 postprocess-bison.py output.c
```

**Note:** Unlike `postprocess-flex.py`, this script modifies the file in-place.

## Validating Zero-Warning Compilation

After running these scripts, the generated code should compile cleanly with
strict warning flags:

```bash
# Test with high warning levels
gcc -Wall -Wextra -Wpedantic -Werror -c generated_lexer.c
gcc -Wall -Wextra -Wpedantic -Werror -c generated_parser.c
```

If warnings still appear after post-processing:

1. Check that you're using compatible Flex/Bison versions (see Requirements)
2. Ensure the scripts are being run correctly (check invocation in build output)
3. Report any persistent warnings as bugs - they should be fixed in the scripts

**The libfsp project's `make check` validates this**: The test lexer and parser
must compile warning-free as part of the test suite.

## Integration Example

See the example at the end of `../Makefile.am` for how to integrate these scripts into a host project's automake build system.

### Key Points

1. **These scripts are for host projects**, not for libfsp itself (libfsp has no Flex/Bison files)
2. **Run in MAINTAINER_MODE only** - generated files should be checked into VCS
3. **Python 3 required** - configure.ac checks for python3/python
4. **Scripts expect specific paths** - adjust `$(top_srcdir)/libfsp/scripts/` based on submodule location

## Host Project Integration Example

Example of how Raptor or Rasqal would integrate these scripts into their
`src/Makefile.am`:

```makefile
BUILT_SOURCES = turtle_lexer.c turtle_lexer.h turtle_parser.c turtle_parser.h

MAINTAINERCLEANFILES = turtle_lexer.c turtle_lexer.h \
turtle_parser.c turtle_parser.h turtle_parser.output

if MAINTAINER_MODE
# Flex lexer with custom config header
turtle_lexer.c: $(srcdir)/turtle_lexer.l turtle_parser.c \
                $(top_srcdir)/libfsp/scripts/postprocess-flex.py
 $(AM_V_GEN) \
 $(LEX) -o$@ $(srcdir)/turtle_lexer.l; \
 for file in turtle_lexer.c turtle_lexer.h; do \
   $(PYTHON3) $(top_srcdir)/libfsp/scripts/postprocess-flex.py \
     -c raptor_config.h $$file > turtle_lexer.t || exit 1; \
   mv -f turtle_lexer.t $$file; \
 done

turtle_lexer.h: turtle_lexer.c ; @exit 0

# Bison parser
turtle_parser.c: $(srcdir)/turtle_parser.y \
                 $(top_srcdir)/libfsp/scripts/postprocess-bison.py
 $(AM_V_GEN) \
 $(BISON) -o $@ $(srcdir)/turtle_parser.y; \
 $(PYTHON3) $(top_srcdir)/libfsp/scripts/postprocess-bison.py $@

turtle_parser.h: turtle_parser.c ; @exit 0
endif
```

**Note:** Use `-c raptor_config.h` or `-c rasqal_config.h` to specify the
project-specific config header name.

## License

These scripts are part of libfsp and are licensed under the same terms:

- LGPL 2.1+ or GPL 2+ or Apache 2.0+

## Original Source

These scripts were copied from the Raptor RDF Parser and Rasqal RDF query projects:

- <https://github.com/dajobe/raptor>
- <https://github.com/dajobe/rasqal>

Copyright (C) 2025 Dave Beckett
